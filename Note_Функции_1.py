#### Если функцию задать несколько раз она переопределяется
#### Если функция возвращает несколько значение в return, то они возвращаются как кортеж

#### Варианты задания аргументов функции
## Без аргументов
def func():
    return 'Аргументы не заданы'
print('Вариант1 \n', func())

## Позиционные аргументы, количество передаваемых аргументов должно соответствовать количеству ожидаемых в функции
def func(a, b, c):
    return a, b, c
print('Вариант2 \n', func(2, 3, 4))

## Ключевые аргументы. При вызове функции точно указываем значение аргументов, при этом порядок можно менять
def func(a, b, c):
    return a, b, c
print('Вариант3 \n', func(c=3, a=2, b=4))

## Смешанные аргументы. Сначала задаются позиционные аргументы (сколько нужно, минимум один),
# потом ключевые в любом порядке, если начали передавать ключевые аргументы, то дальше только ключевые
def func(a, b, c):
    return a, b, c
print('Вариант4 \n', func(2, c=3, b=4))

## Задание аргументов по умолчанию. Если аргумент не передается то в функции должно быть задано значение по умолчанию
# т.е. если у аргумента есть значение по умолчанию, то он может не передаваться, тогда его значение равно значению по умолчанию
# если значения по умолчанию нет, то аргумент должен передаваться ОБЯЗАТЕЛЬНО
# ПРАВИЛО - если начали уже объявляться значения по умолчанию, то уже нельзя объявлять значения НЕ по умолчанию def func(a=2, b, c=4):
def func(a, b=3, c=4):
    return a, b, c
print('Вариант5 \n', func(2, c=5))

def func(a=7, b=3, c=4):
    return a, b, c
print('Вариант6 \n', func(2,c=5))

## Использование * и / в функции
# * - означает что все оргументы после * должны быть строго ключевыми def func(a, b, *, c=4):
# / - означает что все оргументы до / должны быть строго позиционными def func(a, /, b=3, c=4):

## args, kwargs - аргументы которые могут не передаваться, или передаваться в любом количестве.
# *args преобразуется в кортеж
# **kwargs преобразуется в кортеж

def func(a, b, *args, **kwargs):
    print(a)
    print(b)
    print(args)
    print(kwargs)
print('Вариант7')
func(2, 3, 4,5,6, c=7, d=8, e = 9)
# Применяется тоже требование если начали передаваться ключевые аргументы, то позиционные уже не могут передаваться,
# т.е. если один из аргументов был уже задан как ключевой, то *args уже нельзя использовать.
print('Вариант8')
func(2, b=3, c=7, d=8, e = 9)

## Использование typehinting.
# Не влилияет на код, но подсказывает какой тип переменной ожидается на входе и выходе функции
# так же при объявлении типа IDE подсказывает методы, и помечает ошибки.
def func(a:int, b:str = 5) -> str:
    c = a + b
    print(a)
    print(b)
    print(c)
    return c
c = func(4,6)
c = func('4','5')

#### Функция print
## end - чем заканчивать вывод, по умолчанию равно '\n'
## sep - чем разделять вывод, по умолчанию равно ' '
print('Вариант9')
print(4, 5, end = '**', sep='//')
print(4, 5)

#### lambda функция, это простая, безименная, однострочная функция
print('Вариант10')
f = lambda x: x+2
print(f(3))
# либо
print((lambda x, y: x+y)(3,4))

#### Функция map, это функция которая применяет какую либо функцию, к каждому элементу списка.
#и возвращает объект map, который является итератором, выдающим элементы по запросу,
#поэтому к ниму нужно применить еще какую-нибудь функцию работающую со списком, например list, join
print('Вариант11')
a = [1,2,3,4,5]
b = list(map(lambda x: x*2, a)) # умножить все значения списка на 2, и вернуть в виде списка.
print(b)
# В данном случае str это функция переводящая элементы списка в строковый тип
b = ' '.join(map(str, a)) # склеить все значания списка через ' '
print(b)
# В данном случае int это функция переводящая элементы списка в числовой тип
a = ['1','2','3','4','5']
b = sum(map(int, a)) # сумма всех значений в списке
print(b)


#### Функция filter, проверяет каждое значение в списке на предмет соответствия какому либо условию описанному в функции, если соответствует то добавляет его в список.
#и возвращает объект filter, который является итератором, выдающим элементы по запросу,
#поэтому к ниму нужно применить еще какую-нибудь функцию работающую со списком, например list, join
print('Вариант12')
a = [1,2,3,4,5]
b = list(filter(lambda x: x > 3, a)) # выведет список в которы попадут только значения больше 3.
print(b)
b = list(filter(lambda x: x % 2, a)) # выведет список в котором будут числа которые не делятся на 2 ровно (если делятся то значение 0, а это False
print(b)

#### функции map и filter можно заменить с помощью list comprehension (работа со списком в одну строку)
print('Вариант13')
a = [1,2,3,4,5]
b = [i*2 for i in a]
print(b)
a = [1,2,3,4,5]
b = [i for i in a if i > 3]
print(b)
b = [[x for x in range(1, 6)] for y in range(1, 4)] # сначала делаются 1е [] скобки (создается вложенный список), # потом 2е [] (создается внешний список и в него вставляется внутренний список
print(b)

#### Области видимости переменных
# в глобальной зоне видимости и в каждой функции своя переменная а, если вложенная фунуция не находит переменную внутри то ищет на уровень выше.
print('Вариант14')
a = 'Global'
def func():
    a = 'func'
    def inner():
        a = 'inner'
        print(a)
    print(a)
    inner()
func()
print(a)
